<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue系列二：Plugin]]></title>
    <url>%2F2018%2F09%2F20%2FVue%E7%B3%BB%E5%88%972%2F</url>
    <content type="text"><![CDATA[vue支持plugin用法,比如引用一些比较流行的Component库 Element-UI、iView等等,这里总结下Plugin的封装。 在src目录下创建plugins目录存放各种plugin。 ElementUI 按需引入 借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。首先，安装 babel-plugin-component： 1npm install babel-plugin-component -D 将.babelrc 或 babel.config.js 修改为： 123456789101112131415// babel.config.jsmodule.exports = &#123; presets: [ '@vue/app', ], plugins: [ [ 'component', &#123; libraryName: 'element-ui', styleLibraryName: 'theme-chalk', &#125;, ], ],&#125;; 在plugins目录下创建element-ui.js, 在里面引入要用到的组件即可。 1234567891011121314// element-ui.jsimport &#123; DatePicker, Transfer &#125; from 'element-ui';function plugin(Vue) &#123; Vue.component(DatePicker.name, DatePicker); Vue.component(Transfer.name, Transfer);&#125;// Install by default if using the script tagif (typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; window.Vue.use(plugin);&#125;export default plugin; 在main.js引入plugin, 在main.js里引入的各个模块的时候, 推荐分块引入, 并注释。 12// vue pluginsimport ElementUI from '@/view/plugins/element-ui'; 封装一个alert plugin 把alert插件的方法挂在到Vue原型上即可, 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// vue-tada.jsimport swal from 'sweetalert';function plugin(Vue) &#123; Vue.prototype.$tada = swal; Vue.prototype.$tada.success = function success(title, text = '') &#123; return swal(&#123; title, text, icon: 'success', button: '确认', &#125;); &#125;; Vue.prototype.$tada.error = function error(title, text = '') &#123; if (typeof text === 'object') &#123; text = JSON.stringify(text); &#125; return swal(&#123; title, text, icon: 'error', button: '确认', &#125;); &#125;; Vue.prototype.$tada.confirm = function danger(config) &#123; const &#123; title, text, icon = 'warning', dangerMode = true, primaryText = '删除', &#125; = config; return swal(&#123; title, text, icon, closeOnClickOutside: false, buttons: ['取消', primaryText], dangerMode, &#125;); &#125;;&#125;// Install by default if using the script tagif (typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; window.Vue.use(plugin);&#125;export default plugin; 相同的，在main.js里引入即可 12// vue pluginsimport VueTada from '@/view/plugins/vue-tada'; 全局使用： 12345678this.$tada.confirm(&#123; title: 'titleName', text: 'some text',&#125;).then(ok =&gt; &#123; if (ok) &#123; // some operations. &#125;&#125;); V-Chat12345678910// v-chat.jsimport VeLine from 'v-charts/lib/line.common';function install(Vue) &#123; Vue.component(VeLine.name, VeLine);&#125;export default &#123; install,&#125;; 更多Plugin请移步awesome-vue]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue系列一：filter]]></title>
    <url>%2F2018%2F08%2F26%2FVue%E7%B3%BB%E5%88%971%2F</url>
    <content type="text"><![CDATA[前言 在开发项目的过程中，Vue filter的使用是必不可少的。 Vue filter在项目中的使用技巧 为了更方便的使用filter，我们在src目录下创建filters文件夹用来存放项目中要使用的filter. 新建index.js 引入所有的filter. Vue.filter()注册所有filter.1234567891011121314151617181920212223242526272829303132import Vue from 'vue';import &#123; snakeCase &#125; from 'lodash';import instanceStatus from './instance-status.filter';import toUSD from './toUSD.filter';import upperCase from './upper-case.filter';import toFix from './to-fix.filter';import readMore from './read-more.filter';import dateFormate from './date-formate.filter';import fourSpace from './four-space.filter';import noSpace from './no-space.filter';import moneyFormat from './money-format.filter';import telFormate from './tel-formate.filter';import idcardFormate from './idcard-formate.filter';const filters = &#123; instanceStatus, toUSD, upperCase, toFix, readMore, dateFormate, fourSpace, noSpace, moneyFormat, telFormate, idcardFormate&#125;;Object.keys(filters).forEach(key =&gt; &#123; Vue.filter(snakeCase(key), filters[key]);&#125;); 常用的filter 日期格式化 12345import moment from 'moment';export default function dateFormate(date, pattern = 'YYYY-MM-DD HH:mm:ss') &#123; return moment(date).format(pattern);&#125; 金钱格式化 12345678910111213141516171819//金钱三位用 ","隔开export default function moneyFormat(value) &#123; value = value.toString().replace(/\$|\,/g, ''); if (isNaN(value)) &#123; value = "0"; &#125; let sign = (value == (value = Math.abs(value))); value = Math.floor(value * 100 + 0.50000000001); let cents = value % 100; value = Math.floor(value / 100).toString(); if (cents &lt; 10) &#123; cents = "0" + cents &#125; for (var i = 0; i &lt; Math.floor((value.length - (1 + i)) / 3); i++) &#123; value = value.substring(0, value.length - (4 * i + 3)) + ',' + value.substring(value.length - (4 * i + 3)); &#125; return (((sign) ? '' : '-') + value + '.' + cents);&#125; 保留小数后几位 123export default function toFix(value, limit) &#123; return value.toFixed(limit);&#125; 转化成美元$符 123export default function toUSD(value) &#123; return `$$&#123;value&#125;`;&#125; 去除空格 123export default function noSpace(str) &#123; return str.replace(/\s+/g, "");&#125; 卡号格式化（每四位空格隔开） 123export default function fourSpace(value) &#123; return value &amp;&amp; value.replace(/\s/g, '').replace(/(.&#123;4&#125;)/g, "$1 "); &#125; 例如：1234342324322342 =&gt; 1234 3423 2432 2342 身份证格式化 1234//身份证号格式化 前六位 后四位 中间变为星号 ---例如：340888*******5656export default function idcardFormate(value) &#123; return value &amp;&amp; value.replace(/^(.&#123;6&#125;)(?:\d+)(.&#123;4&#125;)$/,"$1*******$2");&#125; 手机号格式化 1234//手机号格式化 中间四位变成星号export default function telFormate(value) &#123; return value &amp;&amp; value.replace(/^(.&#123;3&#125;)(?:\d+)(.&#123;4&#125;)$/,"$1****$2");&#125; 大写格式化 123export default function upper(str) &#123; return str.toUpperCase();&#125; 阅读更多 123export default function readMore(text, len, suffix) &#123; return text.substring(0, len) + suffix;&#125; 例如： 12&lt;div class="summary"&gt;&#123;&#123; article.summary | read_more(110, '...') &#125;&#125;&lt;/div&gt;&lt;div class="action"&gt;&lt;a :href="article.link"&gt;阅读更多&lt;/a&gt;&lt;/div&gt; 更多filter]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web全栈入门]]></title>
    <url>%2F2018%2F07%2F20%2Fweb%E5%85%A8%E6%A0%88%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言 目前，Web开发技术仍在快速发展中，异步开发、新的MVVM前端技术层出不穷。由于Node.js把JavaScript引入了服务器端，因此，原来必须使用PHP/Java/C#/Python/Ruby等其他语言来开发服务器端程序，现在可以使用Node.js开发了！ 用Node.js开发Web服务器端的优势 以前掌握了前端JavaScript的开发人员，现在可以同时编写后端代码； 前后端统一使用JavaScript，就没有切换语言的障碍了； 速度非常快！这得益于Node.js天生是异步的。 Node.js的一些框架工具 Web框架：Express、Sails.js、koa、Meteor、DerbyJS、Total.js、restify等等 ORM框架：Sequelize、ORM2、Bookshelf.js、Objection.js等 模版引擎：Jade、EJS、Swig、Nunjucks、doT.js等 测试框架：Mocha、Expresso、Unit.js、Karma 自动化构建工具：Webpack、Grunt、Gulp 使用node + koa + sequelize + mysql实现crud准备：需要用到的npm包 koa：基于node.js平台的web开发框架 koa-cors：用于解决跨域请求 koa-router：url处理器映射 koa-body：因为Web应用离不开处理表单(例如用户的添加编辑表单)。本质上，表单就是 POST 方法发送到服务器的键值对。koa-body模块可以用来从 POST 请求的数据体里面提取键值对 sequelize：相当于JS端的hibernate mysql2：Node.js的MySQL客户端 如果出现下面的问题就是没安装mysql2依赖 安装依赖1yarn add koa koa-cors koa-router koa-body sequelize mysql2]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工作流]]></title>
    <url>%2F2018%2F07%2F13%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[babel(例如vue项目初识完成后有一个.babelrc文件)：js预编译器，将js的未来，现在使用es6 以前，es6以后使用最新的js语法来编写，运行的代码可以根据需求编译成相应的版本babel 编译jssource_code .babelrc cli target(运行平台)babel 依赖于presets(预处理集)babel的预处理，只是语法糖(例如es5没有class)，它会把es5里面没有的es6语法，实现一遍，例如最基本的const…为什么babel得以运行？因为它有babel-core，它有一系列的语法糖 npm 123npm run devnpm install项目构建的基本流程 postcss 前缀，css变量 stylus/scss/less babel的使用 安装babel 1yarn global add babel-core babel-cli 进入项目 1234567npm init -yyarn add babel-core -Dyarn add babel-presets-env//安装babel插件 yarn add babel-plugin-transform-runtime -D//针对2015第二季度的编译yarn add babel-preset-stage-2 -D babel-cli的一些命令 编译js文件 1babel main.js 编译js文件到目标文件 1babel main.js -o a.js eslint的使用 安装eslint 1yarn add eslint -D 修改package.json 123"scripts": &#123; "eslint": "eslint *.js"&#125; 添加.eslintrc.js配置文件 123456789101112 module.exports = &#123; env: &#123; es6: true, node: true &#125;, extends: 'eslint:recommended', rules: &#123; quotes: ['error', 'single'], semi: ['error', 'always'], indent: ['error', 4] &#125;&#125; 测试代码是否符合规范 1npm run eslint mocha的使用 安装mocha 1yarn add mocha chai -D 初始化 1npm init -y //生成package.json 修改配置文件package.json 123&quot;scripts&quot;: &#123;&quot;mocha&quot;: &quot;mocha tests/&quot;&#125; 新建测试文件tests，注意这个文件名要和配置文件里的要一致 在tests文件里新建测试文件index.spec.js 测试代码 1npm run mocha npm自动化处理 有时候一个项目要有很多工作流，这时候我们就要有这样的需求：用一条命令直接执行运行所有的工作流，就不用npm run eslint、npm run mocha一条一条地输入命令了 同样的，先初始化 1npm init -y 安装自己需要的npm包，例如eslint等 修改配置文件 12345&quot;scripts&quot;: &#123;&quot;lint:js&quot;: &quot;eslint *.js&quot;,&quot;mocha&quot;: &quot;mocha tests/&quot;,&quot;test&quot;: &quot;npm-run-all --parallel lint:js mocha&quot; //配置一个test脚本，用来集合所有命令&#125; 安装npm-run-all（windows系统安装这个保险一点） 1yarn add npm-run-all -D 执行命令 1npm run test]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack学习笔记（基于webpack4.0）]]></title>
    <url>%2F2018%2F07%2F13%2Fwebpack4.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[webpack是一个打包(build)工具，为什么要打包呢？因为现在的前端已经不是常规的(落后的)开发方式（jquery、html、css）交给后端上线，现在是MVVM的开发时代，一切皆可打包 webpack 将现代js开发中的各种新型有用技术，集合打包，这些东西在打包前是无法运行的，（js、es6、stylus不支持浏览器直接执行，.hbs、.vue）在目标容器上运行 在webpack里，一切皆静态资源，webpack将静态资源打包 =&gt; 目标文件（可运行） 安装webpack及webpack-cli1yarn global add webpack webpack-cli 新建项目文件，进入项目初始化生成package.json配置文件 1npm init -y 修改package.json 123 &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --mode production&quot;&#125; 新建webpack.config.js文件(面试常考：手写webpack配置文件) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const path = require('path');//webpack怎么抽离打包css的代码？ExtractTextPluginconst ExtractTextPlugin = require('extract-text-webpack-plugin');//webpack中的html的plugin做的什么事情？ const HtmlWebpackPlugin = require('html-webpack-plugin');const CopyWebpackPlugin = require('copy-webpack-plugin');const webpack = require('webpack');console.log(__dirname); //D:\workspace\webpack\try-webpackconsole.log(path.resolve(__dirname, 'dist')); //D:\workspace\webpack\try-webpack\distmodule.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].js' &#125;, module: &#123; rules: [&#123; // 模块规则（配置 loader、解析器等选项） test: /\.less$/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ 'css-loader', 'less-loader' ] &#125;) &#125;, &#123; test: /\.js$/, include: [ path.resolve(__dirname, 'src') //只处理src目录下的文件 ], use: 'babel-loader' &#125;, &#123; test: /\.(png|jpg|gif)$/, use: [&#123; loader: 'file-loader' &#125;] &#125;, &#123; test: /\.css/, use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ 'css-loader' ] &#125;) &#125;] &#125;, resolve: &#123; //resolve定义一个别名 alias: &#123; utils: path.resolve(__dirname, 'src/utils') &#125;, extensions: ['.js', '.json', '.css', '.less'] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; file: 'index.html', template: 'src/index.html' &#125;), new ExtractTextPlugin('[name].css'), new CopyWebpackPlugin([&#123; from: 'src/assets/favicon.ico', to: 'favicon.ico' &#125;]), //lodash作为工具，是很多组件会使用的，省去了到处import new webpack.ProvidePlugin(&#123; '_': 'lodash' &#125;) ], devServer: &#123; port: '1314', before(app) &#123; app.get('/api/test.json', (req, res) =&gt; &#123; //如果前端用axios请求这个接口，就会返回下面的json res.json(&#123; code: 200, message: 'hello world' &#125;) &#125;) &#125; &#125;&#125;; 从 webpack v4.0.0 开始，可以不用引入一个配置文件。然而，webpack 仍然还是高度可配置的。在开始前你需要先理解四个 核心概念： 入口(entry)：来指定一个入口起点（或多个入口起点）。默认值为 ./src。 输出(output)：指示 webpack 如何去输出、以及在哪里输出你的「bundle、asset 和其他你所打包或使用 webpack 载入的任何内容」。 loader：loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 插件(plugins)：loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 例如： 123456789101112131415 plugins: [ new HtmlWebpackPlugin(&#123; file: 'index.html', template: 'src/index.html' &#125;), new ExtractTextPlugin('[name].css'), new CopyWebpackPlugin([&#123; from: 'src/assets/favicon.ico', to: 'favicon.ico' &#125;]), //lodash作为工具，是很多组件会使用的，省去了到处import new webpack.ProvidePlugin(&#123; '_': 'lodash' &#125;)] 这里是webpack官网的提供的一些插件列表 注意： loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。 面试常考：vue-cli在创建项目的过程中发生了什么？]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB入门]]></title>
    <url>%2F2018%2F07%2F01%2Fmongodb%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL笔记]]></title>
    <url>%2F2018%2F07%2F01%2Fmysql%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 MySQL是一种 关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了 双授权政策，分为社区版和商业版，由于其 体积小、速度快、总体拥有成本低，尤其是 开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。 数据库的分类数据库通常分为 层次式数据库、网络式数据库和 关系式数据库三种。而不同的数据库是按不同的数据结构来联系和组织的。而在当今的互联网中，最常见的数据库模型主要是两种，即 关系型数据库和 非关系型数据库。 关系型数据库代表 Oracle SQL Server MySQL 非关系型数据库代表 MongoDB Redis MySQL的存储引擎MySQL数据库根据应用的需要准备了不同的引擎，不同的引擎侧重点不一样 InnoDB： 事务型数据库的首选引擎，支持ACID事务，支持行级锁定, MySQL 5.5 起成为默认数据库引擎 MyISAM：MySQL 5.0 之前的默认数据库引擎，最为常用。拥有较高的插入，查询速度，但不支持事务 BDB：源自Berkeley DB，事务型数据库的另一种选择，支持Commit 和Rollback等其他事务特性 Memory：所有数据置于内存的存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。并且其内容会在 MySQL 重新启动时丢失 Archive：非常适合存储大量的独立的，作为历史记录的数据。因为它们不经常被读取。Archive 拥有高效的插入速度，但其对查询的支持相对较差Federated 将不同的 MySQL 服务器联合起来，逻辑上组成一个完整的数据库。非常适合分布式应用Cluster/NDB 高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大，安全和性能要求高的应用CSV 逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个 .csv 文件。这是一种普通文本文件，每个数据行占用一个文本行。CSV 存储引擎不支持索引。 BlackHole：黑洞引擎，写入的任何数据都会消失，一般用于记录binlog做复制的中继EXAMPLE 存储引擎是一个不做任何事情的存根引擎。它的目的是作为 MySQL 源代码中的一个例子，用来演示如何开始编写一个新存储引擎。同样，它的主要兴趣是对开发者。EXAMPLE 存储引擎不支持编索引。 各个存储引擎的比较如下图： MySQL数据库操作创建数据库 1create database &lt;数据库名&gt;; 查看数据库 1show databases; 删除数据库 1drop database &lt;数据库名&gt;; 连接数据库 1use &lt;数据库名&gt;; 查看当前数据库的编码12use &lt;数据库名&gt;;show variables like 'character_set_database'; 或1show create database 数据库名; 修改当前数据库的编码1alter database &lt;数据库名&gt; character set utf8; 查看某个数据库的当前状态1status; 或1\s 数据表操作创建数据表 1create table &lt;表名&gt; ( &lt;字段名1&gt; &lt;类型1&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]); 例如： 12345mysql&gt; create table MyClass(&gt; id int(4) not null primary key auto_increment,&gt; name char(20) not null,&gt; sex int(4) not null default '0',&gt; degree double(16,2)); 删除数据表 1drop table &lt;表名&gt;; 查看数据表 1describe &lt;表名&gt;; 向表里插入数据 1Insert into &lt;表名&gt;(字段列表) values (值列表); 查询表数据 1select &lt;字段名&gt; from &lt;表名称&gt; [查询条件]; 删除表中的数据 1delete from &lt;表名&gt; where &lt;表达式&gt; 例如： 1delete from students where id=10; 修改表中数据 1update &lt;表名称&gt; set 列名称=新值 where 更新条件; 例如： 123456//将id为5的手机号改为默认的update students set tel=default where id=5;//将所有人的年龄增加1update students set age=age+1;//将手机号为 13723887766 的姓名改为 "张果", 年龄改为 19update students set name="张果", age=19 where tel="13723887766"; 删除表 1drop table 表名; 修改表结构添加列 1alter table 表名 add 列名 列数据类型 [after 插入位置]; 例如： 1234//在表的最后追加列 address: alter table students add address char(60);//在名为 age 的列后插入列 birthday:alter table students add birthday date after age; 修改列 1alter table 表名 change 列名称 列新名称 新数据类型; 例如： 12//将 name 列的数据类型改为 char(9): alter table students change name name char(9) not null; 删除列 1alter table 表名 drop 列名称; 例如： 12//删除 age 列: alter table students drop age; 重命名表 1alter table 表名 rename 新表名; 例如： 12//重命名 students 表为temp: alter table students rename temp; 修改表名1rename table 原表名 to 新表名; 例如：12//在表MyClass名字更改为YouClassmysql&gt; rename table MyClass to YouClass; 其他命令查看MySQL的编码1show variables like 'character%'; 查看数据库支持的所有字符集1show character set; 或1show char set; 修改MySQL的编码123mysql&gt; SET character_set_client='utf8';mysql&gt; SET character_set_connection='utf8'mysql&gt; SET character_set_results='utf8' 查看MySQL的版本1select version(); 查看当前时间1select now(); 显示年月日显示日 1select DAYOFMONTH(CURRENT_DATE); 显示月 1select MONTH(CURRENT_DATE); 显示年 1select YEAR(CURRENT_DATE); 显示字符串123456select "welecome to my blog!";``` ### 当计算器用```sqlselect ((23*2)/3)+25; 计算字符串长度1select char_length('JoeWright'); //9 日期格式化123select DATE_FORMAT(now(),'%y-%m-%d'); //18-07-01select DATE_FORMAT(now(),'%Y-%m-%d'); //2018-07-01select DATE_FORMAT(now(),'%Y/%m/%d'); // 2018/07/01 添加和减少时间（常用于数据统计）123456select DATE_ADD(date,interval expr unit)select DATE_SUB(date,interval expr unit)//data:日期格式，其中就包括: 如2018-07-01，now() 等格式。//expr：表示数量。//unit：表示单位，支持毫秒(microsecond)，秒(second)，小时(hour)，天(day)，周(week)，年(year)等。 例如：1select date_add(now(),interval 1 day); //2018-07-02 16:47:48 加密函数1select md5(data); 例如：1select md5("JoeWright"); //0851f9b50875d14202b94e2a6eb85a81 字符串拼接1select concat("Joe","Wright"); //JoeWright JSON函数（5.7版本以上支持）1select json_object("name","JoeWright","sex","男"); //&#123;"sex": "男", "name": "JoeWright"&#125; 1select json_array("name","JoeWright","sex","男"); //["name", "JoeWright", "sex", "男"] 12//判断json字符串是否符合规范 1:规范；0:不规范select json_valid('&#123;"sex": "男", "name": "JoeWright"&#125;'); //1]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-devtools安装踩坑记]]></title>
    <url>%2F2018%2F06%2F23%2FVue-devtools%E5%AE%89%E8%A3%85%E4%B8%AD%E8%B8%A9%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前言vue-devtools是一款用来调试vue应用的插件，它能大大地提高vue的调试效率。近期在折腾vue时想使用这款开发利器，结果踩到许多坑，在这里分享给大家。 安装方法按照官方的文档，vue-devtools有两种安装方法，一种是自己手动去克隆它的源码，然后在谷歌浏览器的扩展管理里打开开发者模式，加载已解压的扩展程序。这里是文档如下图： 另一种方法就是翻墙去谷歌商店下载了，这个程序员都懂的（就是爱折腾）,不过也有一些网站可以直接下载谷歌商店的绝大部分插件，例如 http://www.cnplugins.com/、 https://www.crx4chrome.com/ 踩到的坑一开始安装的时候想着试试去手动安装，于是按着文档做了一遍，发现出现一些问题 然后我想先不管，看能不能用吧，结果谷歌开发者工具里并没有出现vue调试面板，上网查了一下发现是引入vue文件出错了：引入压缩版（即生产版）的vue文件是不会出现出现vue调试面板的，当时我是这样引入的:1&lt;script src="https://cdn.bootcss.com/vue/2.5.16/vue.min.js"&gt;&lt;/script&gt; 后来改成未压缩版的（即开发版）：1&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.js&quot;&gt;&lt;/script&gt; 结果发现调试面板出现了！，点开一下发现下面一片空白，我。。。 于是我试着又安装了一次，发现还是卡在npm run build上，此时的我果断放弃手动安装，然后去谷歌商店下载安装，安装完了后发现点击vue插件图标出现一个提示 查找资料后发现只要修改manifest.json的persistent改为true就可以了,这里怎么找到已安装插件的目录呢？在这里我们打开谷歌的设置=&gt;更多工具=&gt;扩展程序,或者直接在地址栏输入chrome://extensions/，找到已经安装好的vue-devtools，复制那串ID，如下图： 因为谷歌浏览器安装好的插件都会存在以插件的id来命名的文件夹里，所以我们直接在磁盘搜索那串ID（我承认这的确很慢。。），所以还是用everything吧，文件太多直接搜就行啦，这里是下载地址,如图： 第一个就是啦，几乎秒出。然后打开该文件夹，找到manifest.json 修改里面的persistent改为true就可以了 但是需要注意的是，再写vue项目是，引入的vue.js要是未压缩的才会出现vue-devtools的调试面板 如果你是引用的是压缩版的vue，调试面板是不会出现的，此时点击vue插件还回提示 意思是Devtools检查不可用，因为它处于生产模式，或者由作者明确禁用。如果要使用压缩版的vue.js的话，在vue文件中加上1Vue.config.devtools = true; 这样，vue-devtools调试面板又出来了😄 总结： 安装完vue-devtools后需要把manifest.json里面的persistent改为true 需要引入未压缩版的vue.jsvue-devtools的调试面板才会出现 如果引入的是压缩版的vue.js,需要在vue文件中加上Vue.config.devtools = true;]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些移动端开发技巧]]></title>
    <url>%2F2018%2F06%2F04%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一、页面缩放1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=0"&gt; width=device-width：设置为设备宽度 width=device-height：设置为设备高度 initial-scale=1.0：第一次进入页面的初始比例 minimum-scale：设置允许缩放的最小比例 maximum-scale：设置允许缩放的最大比例 user-scalable=no/0(或者user-scalable=yes/1)：设置用户不可以缩放页面 二、ontouchstart123&lt;body ontouchstart&gt; ....&lt;/body&gt; 三、一些常用技巧 清除输入框内阴影及框内的高亮边框(weui源码经常使用) 123456selector&#123; border: 0; outline: 0; -webkit-appearance: none; appearance: none;&#125; 移动端禁止用户选中内容框 123456selector&#123; -webkit-user-select: none; -moz-user-select: none; //移动端不需要 -ms-user-select: none; user-select: none; &#125; 去除部分android系统中元素被点击时产生的高亮(weui的按钮样式有用到,面试常考) 12345selector&#123; //-webkit的私有属性 -webkit-tap-highlight-color:rgba(0, 0, 0, 0); tap-highlight-color:rgba(0, 0, 0, 0);&#125; 禁止文本缩放当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以这样禁止： 123html&#123; -webkit-text-size-adjust: 100%;&#125; 解决字体在移动端比例缩小后出现锯齿的问题（抗锯齿,weui表单源码也有用到） 123selector&#123; -webkit-font-smoothing: antialiased;&#125;]]></content>
      <categories>
        <category>移动端H5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入学习this、call、apply、bind]]></title>
    <url>%2F2018%2F05%2F10%2F%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0this%E3%80%81call%E3%80%81apply%E3%80%81bind%2F</url>
    <content type="text"><![CDATA[this的指向问题一直是面试里的常客。也是es5的众坑之一。对于es6而讲，它极大地避免了this带来的错误。但是为了为了维护一些老代码，还是有必要了解this的。 this的指向原则： this 永远指向最后调用它的那个对象（es5）。 匿名函数的this总指向Window对象(全局对象)（es5）。 箭头函数中的 this 只和定义它时候的作用域的 this 有关，而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变的。 全局环境中的 this 是什么浏览器：1console.log(this); //Window node：1console.log(this); //global 函数里执行全局函数执行一个函数被直接调用的时候，属于全局调用，这时候它的 this 指向 全局对象例如：1234function test()&#123; console.log(this);&#125;test();//Window 作为对象的方法调用例如：1234567var obj=&#123; name:"JoeWright", foo:function()&#123; console.log(this); &#125;&#125;;obj.foo();//Object &#123;name: "JoeWright", foo: ƒ&#125; 如果把对象的方法赋值给一个变量，然后直接调用这个变量,这时候,this 指向全局对象。例如：12345678 var obj=&#123; name:"Joe", foo:function()&#123; console.log(this); &#125;&#125;;var test=obj.foo;test();//Window 作为一个构造函数使用this 指向了这个构造函数调用时候实例化出来的对象例如：12345678function Person(name)&#123; this.name=name; console.log(this);&#125;//this 指向了这个构造函数调用时候实例化出来的对象var p1=new Person("JoeWright"); //Person//构造函数其实也是一个函数，如果我们把它当作一个普通函数执行，这个 this 仍然执行全局var p2=Person("Wright");//Window 匿名函数使用（this的一些坑）匿名函数的this总指向Window对象例如：1234567891011var obj=&#123; name:"JoeWright", f1:function()&#123; console.log(this);//Window &#125;, f2:function()&#123; console.log(this);//Object setTimeout(this.f1,1000);//此时this.f1相当于setTimeout 函数的形参fun，即做了fun=this.f1这个操作 &#125;&#125;;obj.f2(); 解决方法（改变this的指向）： 1.使用箭头函数 12345678910111213 var obj=&#123; name:"JoeWright", f1:function()&#123; console.log(this); &#125;, f2:function()&#123; console.log(this);//Object setTimeout(()=&gt;&#123; console.log(this);//Object &#125;,1000); &#125;&#125;;obj.f2(); 2.在函数内部使用that=this（或者_this=this） 1234567891011121314 var obj=&#123; name:"JoeWright", f1:function()&#123; console.log(this); &#125;, f2:function()&#123; console.log(this);//Object var that=this;//上面的this指向的是obj4,这里我们用that变量存储下来 setTimeout(function()&#123; console.log(that);//Object &#125;,1000); &#125;&#125;;obj.f2(); 改变this的指向改变 this 的指向有以下几种方法： 使用 ES6 的箭头函数 在函数内部使用 that = this（或_this = this） 使用 apply、call、bind new 实例化一个对象 1,2两点上面已经讲过，下面介绍下apply、call、bind的用法例如：1234567891011121314151617181920function Cat(name)&#123; this.name=name;&#125;function Dog(name)&#123; this.name=name;&#125;Cat.prototype.eat=function(food)&#123; console.log(this.name+" eat "+food);&#125;Dog.prototype.eat=function(food)&#123; console.log(this.name+" eat "+food);&#125;var c=new Cat("kitty"); var d=new Dog("Bubby"); c.eat("fish"); //kitty eat fishd.eat("meat"); //Bubby eat meatc.eat.apply(d,["fish"]); //Bubby eat fishc.eat.call(d,"fish"); //Bubby eat fishd.eat.call(c,"apple"); //kitty eat appled.eat.bind(c,"apple")(); //kitty eat apple 从上述的例子可知： apply接收的是一个由若干参数组成的数组，而call接收的是若干个参数列表。 bind与call的用法类似，但是bind 创建了一个新的函数，我们必须 手动去调用它。 new关键字改变this的指向 如果函数调用前使用了 new 关键字, 则是调用了构造函数。 例如：12345function Cat(name)&#123; this.name=name;&#125;var c=new Cat("kitty"); console.log(c.name); //kitty new的过程：伪代码：1234567var c=new Cat("kitty"); new Cat&#123; var obj=&#123;&#125;; obj.__proto__=Cat.prototype; var res=Cat.call(obj,"kitty"); return typeof res==="obj"?res:obj;&#125; 1. 先创建一个空对象obj2. 将新创建的空对象的隐式原型指向其构造函数的显式原型3. 使用call改变this的指向4. 如果没有返回值或者返回的是一个非对象值，则将obj返回为一个新对象；如果返回值是一个对象的话，就直接返回该对象。 apply，call，bind的应用场景 嗯，既然call，apply，bind可以改变this的指向，那我们在哪里可以用到呢 （1） 处理伪数组什么是伪数组？先看一个例子吧：12345678&lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1234const oLi=document.getElementsByTagName("li");console.log(oLi.length);//4console.log(oLi); //HTMLCollection(4) [li, li, li, li]console.log(oLi.slice(1,3)); //Uncaught TypeError: oLi.slice is not a function 看到没，上面的oLi就是一个伪数组。它有数组的length属性，但是不可用数组的slice方法。 伪数组的定义： 存在length属性 可以通过数组下标的方式对元素进行访问 能像遍历数组一样遍历 不能使用数组的slice()、push()等方法。 常见的伪数组 函数的argument对象 document.getElementsByTagName()、document.getElementsByClassName()、childNodes/children等方法的返回值（返回的是一个节点列表） 解决办法：伪数组没有这些方法那就借用Array的方法。1[].slice.call(oLi,1,3) //[li, li]（推荐） 或者：12oLi.slice=[].slice; //为oLi添加一个slice方法（会污染数组对象）console.log(oLi.slice(1,3));//[li, li] 如果可以随意改变原对象，可以 直接将其转成真正的数组对象。12Array.prototype.slice.call(oLi);console.log(oLi.slice(1,3)); //[li, li] （2）继承 单继承 123456789function Person(name)&#123; this.name=name;&#125;function Man(sex,name)&#123; this.sex=sex; Person.call(this,name); //继承Person的name&#125;var p=new Man("male","JoeWright");console.log(p.sex,p.name); //male JoeWright 多继承 12345678910111213function Person(name)&#123; this.name=name;&#125;function Man(sex)&#123; this.sex=sex;&#125;function Coder(name,sex,learn)&#123; this.learn=learn; Person.call(this,name); Man.call(this,sex);&#125;var p2=new Coder("JoeWright","male","FE");console.log(p2.name,p2.sex,p2.learn);//JoeWright male FE （3）获取数组的最值 Math.max()方法，支持传递多个参数，比如：Math.max(1,4,2,3,7,5,6)但是它不支持直接传递一个数组作为参数，比如：Math.max(new Array(1,4,2,3,7,5,6))。这里，只要我们有方法把数组，一个一个拆分开来，传递到Math.max()方法中，就实现了传递数组的方法。而apply接收一个数组，并且是将数组中的每个值，分开来，传递给Math.max()方法 例如：12345678var arr=[1,3,6,10,9];console.log(Math.max.apply(null,arr)); //10console.log(Math.min.apply(null,arr)); //1//等价于console.log(Math.max.apply(Math,arr)); //10console.log(Math.min.apply(Math,arr)); //1console.log(Math.max.apply("a",arr)); //10 console.log(Math.min.apply(a,arr)); //Uncaught ReferenceError: a is not defined(a未定义报错) 但为什么上面的例子中apply传的第一个参数为null和Math都会得到相同的结果呢？在网上看了很多解答后，我得出一个结论： 按apply的语法上来讲，apply的第一个参数此时是Math.max()方法运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 换句话说：当我们传Math就相当于Math对象调用max方法，我们传window相当于window调用这个方法，传Number就相当于Number函数对象调用max方法… 但是传入的参数必须是一个对象（或者参数的原始值的自动包装对象），所以我们传123，”aaa”,undefined都可以，但是传入一个未定义的变量是不行的，当然传入null也是可以的。 （4）合并数组例如：1234var arr=[1,3,6,10,9];var arr2=[2,4,8];[].push.apply(arr,arr2);console.log(arr); //[1, 3, 6, 10, 9, 2, 4, 8] 最后：大家觉得有帮助的话，请点个赞哈哈，如果文章中有写的不恰当的地方，欢迎大家指出~]]></content>
      <categories>
        <category>JavaScript笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入学习JavaScript函数]]></title>
    <url>%2F2018%2F05%2F01%2F%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0JavaScript%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言： 函数对于任何一门语言来说都是核心的概念，通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。而JavaScript中最好的特性就是它对函数的实现。它几乎无所不能。但是，函数在JavaScript中并非万能的，就像《JavaScript语言精粹》中所说：函数在JavaScript里也并非万能药。 一、函数对象在JavaScript中函数就是对象，对象是“名值”对的集合并拥有一个连到原型对象的隐藏连接。我们都知道，对象字面量产生的对象连接到Object.prototype，例如：1234var obj=&#123; name:"JoeWright"&#125;;console.log(Object.prototype.isPrototypeOf(obj)); //true 而函数对象连接到Function.prototype（该原型对象本身连接到Object.prototype）。例如：123456var foo=new Function("a","b","return a+b");console.log(foo(2,3)); //5console.log(obj.constructor); //ƒ Object()console.log(Function.prototype.isPrototypeOf(foo)); //true//Function对象本身连接到Object.prototypeconsole.log(Object.prototype.isPrototypeOf(Function)); //true 一些属性： constructor：返回创建该对象的构造函数 length：返回函数定义的参数个数 caller(ECMA标准之外的属性)：返回调用当前函数的函数 argument：返回该函数执行时内置的arguments对象 例如：123456789function foo(a,b,c)&#123; return foo2.caller;&#125;function bar()&#123; return foo2();&#125;console.log(foo.length); //3console.log(foo.name); //fooconsole.log(bar()); //f bar() 注意：Function构造函数虽然使你的脚本在运行时重新定义函数的情况下具有更大的灵活性，但它也会减慢代码的执行速度。为了避免减慢脚本速度，应该尽可能少使用Function构造函数，多使用function关键字的形式声明函数。 二、函数字面量函数字面量包括四部分： 第一部分是保留字function。 第二部分是函数名，它可以被省略（匿名函数）。函数可以用它的名字来递归调用自己。 第三部分是包围在圆括号中的一组参数（形参）。其中每个参数用逗号分隔。 第四部分是包围在花括号中的一组语句 格式如下：123function functionName(parameters) &#123; 执行的代码&#125; 例如：123function add(a,b) &#123; return a+b;&#125; 三、函数的调用 调用一个函数将暂停当前函数的执行，传递控制权和参数给新函数。 函数除了声明时定义的形式参数，每个函数接收两个附加的参数:this和arguments。参数this在面向对象编程中非常重要，它的值取决于调用的模式。 在JavaScript中一共有四种调用模式：方法调用模式、函数调用模式、构造器调用模式和apply调用模式。这些调用模式在如何初始化关键参数this上存在差异。 上面讲到在JavaScript中一共有四种调用模式，在这里我们分别对这几种模式一一详解。 方法调用模式 当一个函数被保存为对象的一个属性时，我们称它为一个方法 当一个方法被调用时，this被绑定到该对象（这句话对于我们理解this关键字非常重要！！！！） 如果一个调用表达式包含一个属性存取表达式（即.表达式或者是[subscript]下标表达式，注意:如果属性不确定，要用[]） 下面是方法调用模式的一个例子：12345678910111213141516var myObj=&#123; name:"JoWright", value:0, increment:function(inc)&#123; this.value+=typeof inc ==="number"?inc:1; &#125;&#125;;myObj.increment(); console.log(myObj.value); //1myObj.increment(3)console.log(myObj.value); //4var key="name"; //将name属性赋给比变量key，此时属性名不确定console.log(myObj.key); //undefinedconsole.log(myObj[key]); //JoeWright this到对象的绑定 发生在调用的时候，这个绑定又称为 “超级”迟绑定（very late binding）。这样的绑定使得函数可以对this 高度复用。通过this可取得它们所属对象的上下文的方法称为公共方法 函数调用模式 当一个函数并非一个对象的属性时，那么它被当作一个函数调用： 1234function add(a,b)&#123; return a+b;&#125;console.log(add(1,2)); //3 当函数以此模式调用时，this被绑定到全局对象（浏览器下为Window，node下为 global）。 例如：12345678910var myObj=&#123; value:1, multiply:function()&#123; var add=function()&#123; return this.value*2; &#125;; console.log(add()); &#125;&#125;;myObj.multiply(); //NaN 为什么是NaN呢？因为add方法是一个匿名函数，此时add函数中的this绑定的是全局对象，不是myObj（实际上add方法是被Window对象调用的，所以它没有对myObj对象的访问权） 解决方法：利用 闭包 的特性（先用that变量来存储this）1234567891011var myObj=&#123; value:1, multiply:function()&#123; var that=this; var add=function()&#123; return that.value*2; &#125;; console.log(add()); &#125;&#125;;myObj.multiply(); //2 构造器调用模式 JavaScript是一门基于原型继承的语言。这意味着对象可以直接从其他对象继承属性。 如果在函数前面带上new关键字来调用（当作构造函数调用），那么将创建一个隐藏连接到改函数的prototype成员的新对象，同时this 将会绑定到那个新对象上。例如： 123456789function Person(name)&#123; this.name=name;&#125;//为Person的所有实例提供一个名为getName的公共方法Person.prototype.getName=function()&#123; return this.name;&#125;var p=new Person("JoeWright");console.log(p);//Person &#123;name: "JoeWright"&#125; 按照约定，构造器函数保存在以大写格式命名的变量里。如果调用构造器函数时没有在前面加上new，可能会发生非常糟糕的事情（即没有编译时的警告，也没有运行时的警告），所以 大写约定非常重要 Apply调用模式（类似的还有call、bind）格式如下：1functionName.apply(thisArg[, [arg1, arg2, ...]]) thisArg：将被绑定给this的值 [arg1,arg2,..]：参数数组（可选） 例如：12345function add(a,b)&#123; return a+b;&#125;var sum=add.apply(null,[3,4]);console.log(sum); //7 12345678910111213function Person(name)&#123; this.name=name;&#125; //为Person的所有实例提供一个名为getName的公共方法Person.prototype.getName=function()&#123; return this.name;&#125;var Pet=&#123; name:"dogg"&#125;;//Pet并没有继承自Person.prototype,但我们可以在Pet上调用getName方法，尽管Pet并没有一个名为getName的方法。var petName=Person.prototype.getName.apply(Pet);console.log(petName); //dogg 四、参数当函数被调用时，会得到一个“免费”奉送的参数，这个参数就是arguments数组（arguments对象）。通过它函数可以访问所有它被调用时传递给它的参数列表，这使得编写一个无须指定参数个数的函数成为可能。 例如：1234567891011//用arguments对象求最大值function max()&#123; var max=0; for(var i=0,len=arguments.length;i&lt;len;i++)&#123; if(arguments[i]&gt;max)&#123; max=arguments[i]; &#125; &#125; return max;&#125;console.log(max(2,1,4,3,7)); //7 arguments对象的callee属性:引用当前被调用的函数对象1234function bar()&#123; return arguments.callee; &#125;console.log(bar()); //ƒ bar() 典型应用：函数的递归调用123456789//匿名函数的递归调用( function(count)&#123; if(count&lt;=3)&#123; console.log(count); arguments.callee(++count); &#125; &#125;)(0);//0 1 2 3 默认参数实现方法一：1234567function add(x,y)&#123; x=x||0; y=y||1; return x+y;&#125;console.log(add()); //1console.log(add(3,4)); //7 实现方法二：1234567function add(x,y)&#123; x=x===undefined?0:x; y=y===undefined?1:y; return x+y;&#125;console.log(add()); //1console.log(add(3,4)); //7 五、返回 return语句可以使函数提前返回。当return被执行时，函数立即返回而不再执行余下的语句。 一个函数总是会返回一个值。如果没有指定值，就返回undefined12345function f(a,b)&#123; return a+b; return "hello JoeWright"; //永远不会被执行&#125;console.log(f(1,2)); //3 六、异常JavaScript提供了一套异常处理机制。异常是干扰程序正常流程的非正常的事故。例如：1234567891011121314151617var add=function(a,b)&#123; if(typeof a!=="number"||typeof b!=="number")&#123; throw&#123; name:"TypeError", message:"add needs numbers" &#125;; &#125; return a+b;&#125;;var try_it=function()&#123; try&#123; add("hello"); &#125;catch(e)&#123; console.log(e.name+":"+e.message); &#125;&#125;try_it(); //TypeError add needs numbers 七、给类型添加方法JavaScript允许给语言的基本类型添加方法。这样的方式对函数（Function）、数组（Array）、字符串（String）、正则表达式（RegExp） 和 布尔值（Boolean） 同样适用。例如：String对象原来没有reverse方法，我们可以从它的原型上扩展该方法。1234String.prototype.reverse=function()&#123; return Array.prototype.reverse.apply(this.split("")).join("");&#125;console.log("hello".reverse()); //olleh 八、递归递归函数是直接或间接地调用自身的一种函数。例如：123456789function sum1(n)&#123; return n==1?1:f3(n-1)+n;&#125;console.log(sum1(100)); //5050//等价于var sum2=function(n)&#123; //匿名函数的递归 return n==1?1:arguments.callee(n-1)+n;&#125;console.log(sum2(100)); //5050 九、作用域在编程语言中，作用域控制着变量与参数的可见性及生命周期。这对开发者来说是一个重要的帮助，因为它减少了名称冲突，并且提供了自动内存管理12345678910111213var fun1=function()&#123; var a=3,b=5; var fun2=function()&#123; var b=7,c=11; console.log(a+" "+b+" "+c); //3 7 11 a+=b+c; console.log(a+" "+b+" "+c); //21 7 11 &#125;; console.log(a+" "+b); //3 5 fun2(); console.log(a+" "+b);// 21 5&#125;;fun1(); 作用域的知识就写这么多，下次的文章深入学习:) 十、闭包各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。所以这里引用阮一峰老师的理解： 闭包就是能够读取其他函数内部变量的函数，闭包让这些变量的值始终保持在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 闭包的例子：123456789function func1()&#123; var n=5; function func2()&#123; console.log(n); &#125; return func2;&#125;var res=func1();res(); //5 上面的例子中，func2函数就是闭包。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 十一、回调回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。 看下面的例子：12345678910111213function addOne(a)&#123; return a+1;&#125;function test(a,b,c,callback)&#123; var array=[]; for(var i=0;i&lt;3;i++)&#123; array[i]=callback(arguments[i]*2); &#125; return array;&#125;console.log(test(10,20,30,addOne)); //21,41,61//匿名函数的写法（推荐）console.log(test(10,20,30,function(a)&#123;return a+1&#125;));//21,41,61 十二、模块模块就是实现特定功能的一组方法。原始写法：123456function f1()&#123; //...&#125;function f2()&#123; //...&#125; 上述函数f1、f2组成了一个模块，要使用时直接调用就可以了缺点：容易造成变量污染 对象写法：123456789var obj=&#123; name:"JoeWright", f1:function()&#123; //... &#125;, f2:function()&#123; //... &#125;&#125;; 上面的函数f1()和f2(），都封装在obj对象里。使用的时候，就是调用这个对象的属性obj.f1()。缺点：暴露所有模块成员，内部状态可以被外部改写，例如：obj.name=&quot;Tom&quot;; 完善：123456789101112131415var obj=&#123;&#125;;Object.defineProperties(obj,&#123; name:&#123; value:"JoeWright", writable:false //设置可写为false（默认为 false） &#125;, f1:function()&#123; //... &#125;, f2:function()&#123; //... &#125;&#125;);obj.name="Joe";console.log(obj.name); //JoeWright 立即执行函数写法：1234567891011121314var obj=(function()&#123; var value="JoeWright"; var f1=function()&#123; //... &#125;; var f2=function()&#123; //... &#125; return &#123; f1:f1, f2:f2 &#125;; &#125;);console.info(obj.value); //undefined 使用上面的写法，外部代码无法读取内部的value变量。 十三、套用函数也是值，从而我们可以用有趣的方式去操作函数值。套用允许我们将函数与传递给它的参数相结合去产生一个新函数。例如：123456function sum1(n)&#123; return n==1?1:f3(n-1)+n;&#125;console.log(sum1(100)); //5050var sum2=sum1; //把sum1函数赋给变量sum2，实现套用console.log(sum2(100)); //5050 完结以上就是我对js函数的一些总结，不足的地方希望小伙伴们能够提出来，大家一起学习，一起进步:)]]></content>
      <categories>
        <category>JavaScript语言精粹</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo打造最简洁的博客]]></title>
    <url>%2F2018%2F04%2F18%2Fgithub%20pages%20%2B%20hexo%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[自己在搞hexo时，整理的一些优秀博文 hexo的next主题个性化教程 github pages + hexo打造自己的博客 添加文章阅读量 hexo next主题配置 hexo中文文档 快速开始创建一个新帖子1$ hexo new "My New Post" 更多信息: 写作 服务器先安装hexo-server1$ npm install hexo-server --save 1$ hexo server 更多信息: Server 生成静态文件1$ hexo generate 更多信息: Generating 发布到远程站点1$ hexo deploy 更多信息: Deployment]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
